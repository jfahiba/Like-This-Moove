if (typeof ICAL === "undefined") typeof window !== "undefined" ? this.ICAL = {} : ICAL = {}; ICAL.foldLength = 75; ICAL.newLineChar = "\r\n"; ICAL.helpers = { initState: function (t, n) { return { buffer: t, line: t, lineNr: n, character: 0, currentData: "", parentData: [] } }, initComponentData: function (t) { return { name: t, type: "COMPONENT", value: [] } }, isStrictlyNaN: function (e) { return typeof e === "number" && isNaN(e) }, strictParseInt: function (e) { var t = parseInt(e, 10); if (ICAL.helpers.isStrictlyNaN(t)) { throw new Error('Could not extract integer from "' + e + '"') } return t }, formatClassType: function (t, n) { if (typeof t === "undefined") return undefined; if (t instanceof n) { return t } return new n(t) }, unescapedIndexOf: function (e, t, n) { while ((n = e.indexOf(t, n)) !== -1) { if (n > 0 && e[n - 1] === "\\") { n += 1 } else { return n } } return -1 }, binsearchInsert: function (e, t, n) { if (!e.length) return 0; var r = 0, i = e.length - 1, s, o; while (r <= i) { s = r + Math.floor((i - r) / 2); o = n(t, e[s]); if (o < 0) i = s - 1; else if (o > 0) r = s + 1; else break } if (o < 0) return s; else if (o > 0) return s + 1; else return s }, dumpn: function () { if (!ICAL.debug) { return "" } if (typeof console !== "undefined" && "log" in console) { ICAL.helpers.dumpn = function (t) { return console.log(t) } } else { ICAL.helpers.dumpn = function (t) { dump(t + "\n") } } return ICAL.helpers.dumpn(arguments[0]) }, mixin: function (e, t) { if (t) { for (var n in t) { e[n] = t[n] } } return e }, isArray: function (e) { return e && (e instanceof Array || typeof e == "array") }, clone: function (e, t) { if (!e || typeof e != "object") { return e } else if (e instanceof Date) { return new Date(e.getTime()) } else if ("clone" in e) { return e.clone() } else if (ICAL.helpers.isArray(e)) { var n = []; for (var r = 0; r < e.length; r++) { n.push(t ? ICAL.helpers.clone(e[r], true) : e[r]) } return n } else { var n = {}; for (var i in e) { if (Object.prototype.hasOwnProperty.call(e, i)) { if (t) { n[i] = ICAL.helpers.clone(e[i], true) } else { n[i] = e[i] } } } return n } }, unfoldline: function (t) { var n = true; var r = ""; while (n) { n = false; var i = t.buffer.search(/\r?\n/); if (i > -1) { var s = t.buffer[i] == "\r" ? 2 : 1; var o = t.buffer.substr(i + s, 1); if (o.match(/^[ \t]$/)) { n = true; r += t.buffer.substr(0, i); t.buffer = t.buffer.substr(i + s + 1) } else { r += t.buffer.substr(0, i); t.buffer = t.buffer.substr(i + s) } } else { r += t.buffer; t.buffer = "" } } return r }, foldline: function (t) { var n = ""; var r = t || ""; while (r.length) { n += ICAL.newLineChar + " " + r.substr(0, ICAL.foldLength); r = r.substr(ICAL.foldLength) } return n.substr(ICAL.newLineChar.length + 1) }, ensureKeyExists: function (e, t, n) { if (!(t in e)) { e[t] = n } }, hasKey: function (e, t) { return e && t in e && e[t] }, pad2: function (t) { if (typeof t !== "string") { if (typeof t === "number") { t = parseInt(t) } t = String(t) } var n = t.length; switch (n) { case 0: return "00"; case 1: return "0" + t; default: return t } }, trunc: function (t) { return t < 0 ? Math.ceil(t) : Math.floor(t) } }; typeof ICAL === "undefined" ? ICAL = {} : ""; ICAL.design = function () { "use strict"; function t() { Error.apply(this, arguments) } function n(e) { switch (e) { case "\\\\": return "\\"; case "\\;": return ";"; case "\\,": return ","; case "\\n": case "\\N": return "\n"; default: return e } } function r(t) { if (t.indexOf("\\") === -1) { return t } return t.replace(e, n) } function i(e, t) { var n = t.indexOf("UNTIL="); if (n === -1) { return t } n += 6; var r = t.substr(0, n); var i; var o; var u = t.indexOf(";", n); if (u === -1) { i = ""; o = t.substr(n) } else { i = t.substr(u); o = t.substr(n, u - n) } if (o.length > 10) { o = s.value["date-time"][e](o) } else { o = s.value.date[e](o) } return r + o + i } var e = /\\\\|\\;|\\,|\\[Nn]/g; t.prototype = { __proto__: Error.prototype }; var s = { DecorationError: t, defaultType: "text", param: { cutype: { values: ["INDIVIDUAL", "GROUP", "RESOURCE", "ROOM", "UNKNOWN"], allowXName: true, allowIanaToken: true }, "delegated-from": { valueType: "cal-address", multiValue: "," }, "delegated-to": { valueType: "cal-address", multiValue: "," }, encoding: { values: ["8BIT", "BASE64"] }, fbtype: { values: ["FREE", "BUSY", "BUSY-UNAVAILABLE", "BUSY-TENTATIVE"], allowXName: true, allowIanaToken: true }, member: { valueType: "cal-address", multiValue: "," }, partstat: { values: ["NEEDS-ACTION", "ACCEPTED", "DECLINED", "TENTATIVE", "DELEGATED", "COMPLETED", "IN-PROCESS"], allowXName: true, allowIanaToken: true }, range: { values: ["THISLANDFUTURE"] }, related: { values: ["START", "END"] }, reltype: { values: ["PARENT", "CHILD", "SIBLING"], allowXName: true, allowIanaToken: true }, role: { values: ["REQ-PARTICIPANT", "CHAIR", "OPT-PARTICIPANT", "NON-PARTICIPANT"], allowXName: true, allowIanaToken: true }, rsvp: { valueType: "boolean" }, "sent-by": { valueType: "cal-address" }, tzid: { matches: /^\// }, value: { values: ["binary", "boolean", "cal-address", "date", "date-time", "duration", "float", "integer", "period", "recur", "text", "time", "uri", "utc-offset"], allowXName: true, allowIanaToken: true } }, value: { binary: { decorate: function (e) { return ICAL.Binary.fromString(e) }, undecorate: function (e) { return e.toString() } }, "boolean": { values: ["TRUE", "FALSE"], fromICAL: function (e) { switch (e) { case "TRUE": return true; case "FALSE": return false; default: return false } }, toICAL: function (e) { if (e) { return "TRUE" } return "FALSE" } }, "cal-address": {}, date: { decorate: function (e, t) { return ICAL.Time.fromDateString(e, t) }, undecorate: function (e) { return e.toString() }, fromICAL: function (e) { var t = e.substr(0, 4) + "-" + e.substr(4, 2) + "-" + e.substr(6, 2); if (e[8] === "Z") { t += "Z" } return t }, toICAL: function (e) { if (e.length > 11) { return e } var t = e.substr(0, 4) + e.substr(5, 2) + e.substr(8, 2); if (e[10] === "Z") { t += "Z" } return t } }, "date-time": { fromICAL: function (e) { var t = e.substr(0, 4) + "-" + e.substr(4, 2) + "-" + e.substr(6, 2) + "T" + e.substr(9, 2) + ":" + e.substr(11, 2) + ":" + e.substr(13, 2); if (e[15] === "Z") { t += "Z" } return t }, toICAL: function (e) { if (e.length < 19) { return e } var t = e.substr(0, 4) + e.substr(5, 2) + e.substr(8, 5) + e.substr(14, 2) + e.substr(17, 2); if (e[19] === "Z") { t += "Z" } return t }, decorate: function (e, t) { return ICAL.Time.fromDateTimeString(e, t) }, undecorate: function (e) { return e.toString() } }, duration: { decorate: function (e) { return ICAL.Duration.fromString(e) }, undecorate: function (e) { return e.toString() } }, "float": { matches: /^[+-]?\d+\.\d+$/, decorate: function (e) { return ICAL.Value.fromString(e, "float") }, fromICAL: function (e) { var t = parseFloat(e); if (ICAL.helpers.isStrictlyNaN(t)) { return 0 } return t }, toICAL: function (e) { return String(e) } }, integer: { fromICAL: function (e) { var t = parseInt(e); if (ICAL.helpers.isStrictlyNaN(t)) { return 0 } return t }, toICAL: function (e) { return String(e) } }, period: { fromICAL: function (e) { var t = e.split("/"); var n = s.value["date-time"].fromICAL(t[0]) + "/"; if (ICAL.Duration.isValueString(t[1])) { n += t[1] } else { n += s.value["date-time"].fromICAL(t[1]) } return n }, toICAL: function (e) { var t = e.split("/"); var n = s.value["date-time"].toICAL(t[0]) + "/"; if (ICAL.Duration.isValueString(t[1])) { n += t[1] } else { n += s.value["date-time"].toICAL(t[1]) } return n }, decorate: function (e, t) { return ICAL.Period.fromString(e, t) }, undecorate: function (e) { return e.toString() } }, recur: { fromICAL: i.bind(this, "fromICAL"), toICAL: i.bind(this, "toICAL"), decorate: function (t) { return ICAL.Recur.fromString(t) }, undecorate: function (e) { return e.toString() } }, text: { matches: /.*/, fromICAL: function (e, t) { return r(e) }, toICAL: function (t, n) { return t.replace(/\\|;|,|\n/g, function (e) { switch (e) { case "\\": return "\\\\"; case ";": return "\\;"; case ",": return "\\,"; case "\n": return "\\n"; default: return e } }) } }, time: { fromICAL: function (e) { if (e.length < 6) { return e } var t = e.substr(0, 2) + ":" + e.substr(2, 2) + ":" + e.substr(4, 2); if (e[6] === "Z") { t += "Z" } return t }, toICAL: function (e) { if (e.length < 8) { return e } var t = e.substr(0, 2) + e.substr(3, 2) + e.substr(6, 2); if (e[8] === "Z") { t += "Z" } return t } }, uri: {}, "utc-offset": { toICAL: function (e) { if (e.length < 7) { return e.substr(0, 3) + e.substr(4, 2) } else { return e.substr(0, 3) + e.substr(4, 2) + e.substr(7, 2) } }, fromICAL: function (e) { if (e.length < 6) { return e.substr(0, 3) + ":" + e.substr(3, 2) } else { return e.substr(0, 3) + ":" + e.substr(3, 2) + ":" + e.substr(5, 2) } }, decorate: function (e) { return ICAL.UtcOffset.fromString(e) }, undecorate: function (e) { return e.toString() } } }, property: { decorate: function (t, n) { return new ICAL.Property(t, n) }, attach: { defaultType: "uri" }, attendee: { defaultType: "cal-address" }, categories: { defaultType: "text", multiValue: "," }, completed: { defaultType: "date-time" }, created: { defaultType: "date-time" }, dtend: { defaultType: "date-time", allowedTypes: ["date-time", "date"] }, dtstamp: { defaultType: "date-time" }, dtstart: { defaultType: "date-time", allowedTypes: ["date-time", "date"] }, due: { defaultType: "date-time", allowedTypes: ["date-time", "date"] }, duration: { defaultType: "duration" }, exdate: { defaultType: "date-time", allowedTypes: ["date-time", "date"], multiValue: "," }, exrule: { defaultType: "recur" }, freebusy: { defaultType: "period", multiValue: "," }, geo: { defaultType: "float", multiValue: ";" }, "last-modified": { defaultType: "date-time" }, organizer: { defaultType: "cal-address" }, "percent-complete": { defaultType: "integer" }, repeat: { defaultType: "integer" }, rdate: { defaultType: "date-time", allowedTypes: ["date-time", "date", "period"], multiValue: ",", detectType: function (e) { if (e.indexOf("/") !== -1) { return "period" } return e.indexOf("T") === -1 ? "date" : "date-time" } }, "recurrence-id": { defaultType: "date-time", allowedTypes: ["date-time", "date"] }, resources: { defaultType: "text", multiValue: "," }, "request-status": { defaultType: "text", multiValue: ";" }, priority: { defaultType: "integer" }, rrule: { defaultType: "recur" }, sequence: { defaultType: "integer" }, trigger: { defaultType: "duration", allowedTypes: ["duration", "date-time"] }, tzoffsetfrom: { defaultType: "utc-offset" }, tzoffsetto: { defaultType: "utc-offset" }, tzurl: { defaultType: "uri" }, url: { defaultType: "uri" } }, component: { decorate: function (t, n) { return new ICAL.Component(t, n) }, vevent: {} } }; return s }(); ICAL.stringify = function () { "use strict"; function i(t) { if (!t[0] || t[0] !== "icalendar") { throw new Error("must provide full jCal document") } var n = 1; var r = t.length; var s = ""; for (; n < r; n++) { s += i.component(t[n]) + e } return s } var e = "\r\n"; var t = "text"; var n = ICAL.design; var r = ICAL.helpers; i.component = function (t) { var n = t[0].toUpperCase(); var r = "BEGIN:" + n + e; var s = t[1]; var o = 0; var u = s.length; for (; o < u; o++) { r += i.property(s[o]) + e } var a = t[2]; var f = 0; var l = a.length; for (; f < l; f++) { r += i.component(a[f]) + e } r += "END:" + n; return r }; i.property = function (e) { var r = e[0].toUpperCase(); var s = e[0]; var o = e[1]; var u = r; var a; for (a in o) { if (o.hasOwnProperty(a)) { u += ";" + a.toUpperCase(); u += "=" + i.propertyValue(o[a]) } } if (e.length === 3) { if (!a) { u += ":" } return u } var f = e[2]; var l; var c = false; var h = false; if (s in n.property) { l = n.property[s]; if ("multiValue" in l) { c = l.multiValue } if ("defaultType" in l) { if (f === l.defaultType) { h = true } } else { if (f === t) { h = true } } } else { if (f === t) { h = true } } if (!h) { u += ";VALUE=" + f.toUpperCase() } u += ":"; if (c) { u += i.multiValue(e.slice(3), c, f) } else { u += i.value(e[3], f) } return ICAL.helpers.foldline(u) }; i.propertyValue = function (e) { if (r.unescapedIndexOf(e, ",") === -1 && r.unescapedIndexOf(e, ":") === -1 && r.unescapedIndexOf(e, ";") === -1) { return e } return '"' + e + '"' }; i.multiValue = function (e, t, n) { var r = ""; var s = e.length; var o = 0; for (; o < s; o++) { r += i.value(e[o], n); if (o !== s - 1) { r += t } } return r }; i.value = function (e, t) { if (t in n.value && "toICAL" in n.value[t]) { return n.value[t].toICAL(e) } return e }; return i }(); ICAL.parse = function () { "use strict"; function a(e) { this.message = e; try { throw new Error } catch (t) { var n = t.stack.split("\n"); n.shift(); this.stack = n.join("\n") } } function f(e) { var t = {}; var n = t.component = ["icalendar"]; t.stack = [n]; f._eachLine(e, function (e, n) { f._handleContentLine(n, t) }); if (t.stack.length > 1) {/*throw new a("invalid ical body. component began but did not end")*/return; } t = ""; return n } var e = /[^ \t]/; var t = ","; var n = ":"; var r = ";"; var i = "="; var s = "text"; var o = ICAL.design; var u = ICAL.helpers; a.prototype = { __proto__: Error.prototype }; f.ParserError = a; f._formatName = function (e) { return e.toLowerCase() }; f._handleContentLine = function (e, t) { var i = e.indexOf(n); var u = e.indexOf(r); var l; var c; var h; var p; var d = {}; if (u !== -1 && i !== -1) { if (u > i) { u = -1 } } var v; if (u !== -1) { h = e.substring(0, u).toLowerCase(); v = f._parseParameters(e.substring(u), 0); d = v[0]; l = v[1].length + v[2] + u; if ((c = e.substring(l).indexOf(n)) !== -1) { p = e.substring(l + c + 1) } } else if (i !== -1) { h = e.substring(0, i).toLowerCase(); p = e.substring(i + 1); if (h === "begin") { var m = [p.toLowerCase(), [], []]; if (t.stack.length === 1) { t.component.push(m) } else { t.component[2].push(m) } t.stack.push(t.component); t.component = m; return } else if (h === "end") { t.component = t.stack.pop(); return } } else {/*throw new a('invalid line (no token ";" or ":") "'+e+'"')*/return; } var g; var y = false; var b; if (h in o.property) { b = o.property[h]; if ("multiValue" in b) { y = b.multiValue } if (p && "detectType" in b) { g = b.detectType(p) } } if (!g) { if (!("value" in d)) { if (b) { g = b.defaultType } else { g = s } } else { g = d.value.toLowerCase() } } delete d.value; if (p) { if (y) { var w = [h, d, g]; f._parseMultiValue(p, y, g, w) } else { p = f._parseValue(p, g); var w = [h, d, g, p] } } else { var w = [h, d, g] } t.component[1].push(w) }; f._parseValue = function (e, t) { if (t in o.value && "fromICAL" in o.value[t]) { return o.value[t].fromICAL(e) } return e }; f._parseParameters = function (e, t) { var a = t; var l = 0; var c = i; var h = {}; var p; var d; var v; while (l !== false && (l = u.unescapedIndexOf(e, c, l + 1)) !== -1) { p = e.substr(a + 1, l - a - 1); var m = e[l + 1]; if (m === '"') { var g = l + 2; l = u.unescapedIndexOf(e, '"', g); d = e.substr(g, l - g); a = u.unescapedIndexOf(e, r, l) } else { var g = l + 1; var y = u.unescapedIndexOf(e, r, g); if (y === -1) { y = u.unescapedIndexOf(e, n, g); if (y === -1) { y = e.length } l = false } else { a = y } d = e.substr(g, y - g) } if (p in o.param && o.param[p].valueType) { v = o.param[p].valueType } else { v = s } h[p.toLowerCase()] = f._parseValue(d, v) } return [h, d, g] }; f._parseMultiValue = function (e, t, n, r) { var i = 0; var s = 0; while ((i = u.unescapedIndexOf(e, t, s)) !== -1) { var o = e.substr(s, i - s); r.push(f._parseValue(o, n)); s = i + 1 } r.push(f._parseValue(e.substr(s), n)); return r }; f._eachLine = function (t, n) { var r = t.length; var i = t.search(e); var s = i; var o; var u; var a; do { s = t.indexOf("\n", i) + 1; if (t[s - 2] === "\r") { a = 2 } else { a = 1 } if (s === 0) { s = r; a = 0 } u = t[i]; if (u === " " || u === "	") { o += t.substr(i + 1, s - i - (a + 1)) } else { if (o) n(null, o); o = t.substr(i, s - i - a) } i = s } while (s !== r); o = o.trim(); if (o.length) n(null, o) }; return f }(); ICAL.Component = function () { "use strict"; function r(e, t) { if (typeof e === "string") { e = [e, [], []] } this.jCal = e; this.parent = t || null } var e = 1; var t = 2; var n = 0; r.prototype = { _hydratedPropertyCount: 0, _hydratedComponentCount: 0, get name() { return this.jCal[n] }, _hydrateComponent: function (e) { if (!this._components) { this._components = []; this._hydratedComponentCount = 0 } if (this._components[e]) { return this._components[e] } var n = new r(this.jCal[t][e], this); this._hydratedComponentCount++; return this._components[e] = n }, _hydrateProperty: function (t) { if (!this._properties) { this._properties = []; this._hydratedPropertyCount = 0 } if (this._properties[t]) { return this._properties[t] } var n = new ICAL.Property(this.jCal[e][t], this); this._hydratedPropertyCount++; return this._properties[t] = n }, getFirstSubcomponent: function (e) { if (e) { var r = 0; var i = this.jCal[t]; var s = i.length; for (; r < s; r++) { if (i[r][n] === e) { var o = this._hydrateComponent(r); return o } } } else { if (this.jCal[t].length) { return this._hydrateComponent(0) } } return "" }, getAllSubcomponents: function (e) { var r = this.jCal[t].length; if (e) { var i = this.jCal[t]; var s = []; var o = 0; for (; o < r; o++) { if (e === i[o][n]) { s.push(this._hydrateComponent(o)) } } return s } else { if (!this._components || this._hydratedComponentCount !== r) { var o = 0; for (; o < r; o++) { this._hydrateComponent(o) } } return this._components } }, hasProperty: function (t) { var r = this.jCal[e]; var i = r.length; var s = 0; for (; s < i; s++) { if (r[s][n] === t) { return true } } return false }, getFirstProperty: function (t) { if (t) { var r = 0; var i = this.jCal[e]; var s = i.length; for (; r < s; r++) { if (i[r][n] === t) { var o = this._hydrateProperty(r); return o } } } else { if (this.jCal[e].length) { return this._hydrateProperty(0) } } return "" }, getFirstPropertyValue: function (e) { var t = this.getFirstProperty(e); if (t) { return t.getFirstValue() } return "" }, getAllProperties: function (t) { var r = this.jCal[e].length; if (t) { var i = this.jCal[e]; var s = []; var o = 0; for (; o < r; o++) { if (t === i[o][n]) { s.push(this._hydrateProperty(o)) } } return s } else { if (!this._properties || this._hydratedPropertyCount !== r) { var o = 0; for (; o < r; o++) { this._hydrateProperty(o) } } return this._properties } return "" }, _removeObjectByIndex: function (e, t, n) { if (t && t[n]) { var r = t[n]; if ("parent" in r) { r.parent = null } t.splice(n, 1) } this.jCal[e].splice(n, 1) }, _removeObject: function (e, t, r) { var i = 0; var s = this.jCal[e]; var o = s.length; var u = this[t]; if (typeof r === "string") { for (; i < o; i++) { if (s[i][n] === r) { this._removeObjectByIndex(e, u, i); return true } } } else if (u) { for (; i < o; i++) { if (u[i] && u[i] === r) { this._removeObjectByIndex(e, u, i); return true } } } return false }, _removeAllObjects: function (e, t, r) { var i = this[t]; var s = this.jCal[e]; var o = s.length - 1; for (; o >= 0; o--) { if (!r || s[o][n] === r) { this._removeObjectByIndex(e, i, o) } } }, addSubcomponent: function (e) { if (!this._components) { this._components = []; this._hydratedComponentCount = 0 } if (e.parent) { e.parent.removeSubcomponent(e) } var n = this.jCal[t].push(e.jCal); this._components[n - 1] = e; this._hydratedComponentCount++; e.parent = this }, removeSubcomponent: function (e) { var n = this._removeObject(t, "_components", e); if (n) { this._hydratedComponentCount-- } return n }, removeAllSubcomponents: function (e) { var n = this._removeAllObjects(t, "_components", e); this._hydratedComponentCount = 0; return n }, addProperty: function (t) { if (!(t instanceof ICAL.Property)) { throw new TypeError("must instance of ICAL.Property") } if (!this._properties) { this._properties = []; this._hydratedPropertyCount = 0 } if (t.parent) { t.parent.removeProperty(t) } var n = this.jCal[e].push(t.jCal); this._properties[n - 1] = t; this._hydratedPropertyCount++; t.parent = this }, addPropertyWithValue: function (e, t) { var n = new ICAL.Property(e); n.setValue(t); this.addProperty(n); return n }, updatePropertyWithValue: function (e, t) { var n = this.getFirstProperty(e); if (n) { n.setValue(t) } else { n = this.addPropertyWithValue(e, t) } return n }, removeProperty: function (t) { var n = this._removeObject(e, "_properties", t); if (n) { this._hydratedPropertyCount-- } return n }, removeAllProperties: function (t) { var n = this._removeAllObjects(e, "_properties", t); this._hydratedPropertyCount = 0; return n }, toJSON: function () { return this.jCal }, toString: function () { return ICAL.stringify.component(this.jCal) } }; return r }(); ICAL.Property = function () { "use strict"; function s(e, t) { if (typeof e === "string") { var n = e; if (n in i.property) { var r = i.property[n]; if ("defaultType" in r) { var s = r.defaultType } else { var s = i.defaultType } } else { var s = i.defaultType } e = [n, {}, s] } this.jCal = e; this.parent = t || null; this._updateType() } var e = 0; var t = 1; var n = 2; var r = 3; var i = ICAL.design; s.prototype = { get type() { return this.jCal[n] }, get name() { return this.jCal[e] }, _updateType: function () { if (this.type in i.value) { var e = i.value[this.type]; if ("decorate" in i.value[this.type]) { this.isDecorated = true } else { this.isDecorated = false } if (this.name in i.property) { if ("multiValue" in i.property[this.name]) { this.isMultiValue = true } else { this.isMultiValue = false } } } }, _hydrateValue: function (e) { if (this._values && this._values[e]) { return this._values[e] } if (this.jCal.length <= r + e) { return "" } if (this.isDecorated) { if (!this._values) { this._values = [] } return this._values[e] = this._decorate(this.jCal[r + e]) } else { return this.jCal[r + e] } }, _decorate: function (e) { return i.value[this.type].decorate(e, this) }, _undecorate: function (e) { return i.value[this.type].undecorate(e, this) }, _setDecoratedValue: function (e, t) { if (!this._values) { this._values = [] } if (typeof e === "object" && "icaltype" in e) { this.jCal[r + t] = this._undecorate(e); this._values[t] = e } else { this.jCal[r + t] = e; this._values[t] = this._decorate(e) } }, getParameter: function (e) { return this.jCal[t][e] }, setParameter: function (e, n) { this.jCal[t][e] = n }, removeParameter: function (e) { return delete this.jCal[t][e] }, getDefaultType: function () { var e = this.name; if (e in i.property) { var t = i.property[e]; if ("defaultType" in t) { return t.defaultType } } return "" }, resetType: function (e) { this.removeAllValues(); this.jCal[n] = e; this._updateType() }, getFirstValue: function () { return this._hydrateValue(0) }, getValues: function () { var e = this.jCal.length - r; if (e < 1) { return [] } var t = 0; var n = []; for (; t < e; t++) { n[t] = this._hydrateValue(t) } return n }, removeAllValues: function () { if (this._values) { this._values.length = 0 } this.jCal.length = 3 }, setValues: function (e) { if (!this.isMultiValue) { throw new Error(this.name + ": does not not support mulitValue.\n" + "override isMultiValue") } var t = e.length; var n = 0; this.removeAllValues(); if (t > 0 && typeof e[0] === "object" && "icaltype" in e[0]) { this.resetType(e[0].icaltype) } if (this.isDecorated) { for (; n < t; n++) { this._setDecoratedValue(e[n], n) } } else { for (; n < t; n++) { this.jCal[r + n] = e[n] } } }, setValue: function (e) { this.removeAllValues(); if (typeof e === "object" && "icaltype" in e) { this.resetType(e.icaltype) } if (this.isDecorated) { this._setDecoratedValue(e, 0) } else { this.jCal[r] = e } }, toJSON: function () { return this.jCal }, toICAL: function () { return ICAL.stringify.property(this.jCal) } }; return s }(); ICAL.UtcOffset = function () { function e(e) { this.hours = e.hours; this.minutes = e.minutes; this.factor = e.factor } e.prototype = { hours: null, minutes: null, factor: null, icaltype: "utc-offset", toString: function t() { return (this.factor == 1 ? "+" : "-") + ICAL.helpers.pad2(this.hours) + ":" + ICAL.helpers.pad2(this.minutes) } }; e.fromString = function (e) { var t = {}; t.factor = e[0] === "+" ? 1 : -1; t.hours = ICAL.helpers.strictParseInt(e.substr(1, 2)); t.minutes = ICAL.helpers.strictParseInt(e.substr(4, 2)); return new ICAL.UtcOffset(t) }; return e }(); ICAL.Binary = function () { function e(e) { this.value = e } e.prototype = { icaltype: "binary", decodeValue: function () { return this._b64_decode(this.value) }, setEncodedValue: function (t) { this.value = this._b64_encode(t) }, _b64_encode: function (t) { var n = "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "abcdefghijklmnopqrstuvwxyz0123456789+/="; var r, i, s, o, u, a, f, l, c = 0, h = 0, p = "", d = []; if (!t) { return t } do { r = t.charCodeAt(c++); i = t.charCodeAt(c++); s = t.charCodeAt(c++); l = r << 16 | i << 8 | s; o = l >> 18 & 63; u = l >> 12 & 63; a = l >> 6 & 63; f = l & 63; d[h++] = n.charAt(o) + n.charAt(u) + n.charAt(a) + n.charAt(f) } while (c < t.length); p = d.join(""); var v = t.length % 3; return (v ? p.slice(0, v - 3) : p) + "===".slice(v || 3) }, _b64_decode: function (t) { var n = "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "abcdefghijklmnopqrstuvwxyz0123456789+/="; var r, i, s, o, u, a, f, l, c = 0, h = 0, p = "", d = []; if (!t) { return t } t += ""; do { o = n.indexOf(t.charAt(c++)); u = n.indexOf(t.charAt(c++)); a = n.indexOf(t.charAt(c++)); f = n.indexOf(t.charAt(c++)); l = o << 18 | u << 12 | a << 6 | f; r = l >> 16 & 255; i = l >> 8 & 255; s = l & 255; if (a == 64) { d[h++] = String.fromCharCode(r) } else if (f == 64) { d[h++] = String.fromCharCode(r, i) } else { d[h++] = String.fromCharCode(r, i, s) } } while (c < t.length); p = d.join(""); return p }, toString: function () { return this.value } }; e.fromString = function (t) { return new e(t) }; return e }(); typeof ICAL === "undefined" ? ICAL = {} : ""; (function () { ICAL.Period = function (t) { this.wrappedJSObject = this; if (t && "start" in t) { if (t.start && !(t.start instanceof ICAL.Time)) { throw new TypeError(".start must be an instance of ICAL.Time") } this.start = t.start } if (t && t.end && t.duration) { throw new Error("cannot accept both end and duration") } if (t && "end" in t) { if (t.end && !(t.end instanceof ICAL.Time)) { throw new TypeError(".end must be an instance of ICAL.Time") } this.end = t.end } if (t && "duration" in t) { if (t.duration && !(t.duration instanceof ICAL.Duration)) { throw new TypeError(".duration must be an instance of ICAL.Duration") } this.duration = t.duration } }; ICAL.Period.prototype = { start: null, end: null, duration: null, icalclass: "icalperiod", icaltype: "period", clone: function () { return ICAL.Period.fromData({ start: this.start ? this.start.clone() : null, end: this.end ? this.end.clone() : null, duration: this.duration ? this.duration.clone() : null }) }, getDuration: function () { if (this.duration) { return this.duration } else { return this.end.subtractDate(this.start) } }, getEnd: function () { if (this.end) { return this.end } else { var e = this.start.clone(); e.addDuration(this.duration); return e } }, toString: function e() { return this.start + "/" + (this.end || this.duration) }, toICALString: function () { return this.start.toICALString() + "/" + (this.end || this.duration).toICALString() } }; ICAL.Period.fromString = function (t, n) { var r = t.split("/"); if (r.length !== 2) { throw new Error('Invalid string value: "' + t + '" must contain a "/" char.') } var i = { start: ICAL.Time.fromDateTimeString(r[0], n) }; var s = r[1]; if (ICAL.Duration.isValueString(s)) { i.duration = ICAL.Duration.fromString(s) } else { i.end = ICAL.Time.fromDateTimeString(s, n) } return new ICAL.Period(i) }; ICAL.Period.fromData = function (t) { return new ICAL.Period(t) } })(); typeof ICAL === "undefined" ? ICAL = {} : ""; (function () { function t(e, t, n) { var r; switch (e) { case "P": if (t && t === "-") { n.isNegative = true } else { n.isNegative = false } break; case "D": r = "days"; break; case "W": r = "weeks"; break; case "H": r = "hours"; break; case "M": r = "minutes"; break; case "S": r = "seconds"; break; default: return 0 } if (r) { if (!t && t !== 0) { throw new Error('invalid duration value: Missing number before "' + e + '"') } var i = parseInt(t, 10); if (ICAL.helpers.isStrictlyNaN(i)) { throw new Error('invalid duration value: Invalid number "' + t + '" before "' + e + '"') } n[r] = i } return 1 } var e = /([PDWHMTS]{1,1})/; ICAL.Duration = function (t) { this.wrappedJSObject = this; this.fromData(t) }; ICAL.Duration.prototype = { weeks: 0, days: 0, hours: 0, minutes: 0, seconds: 0, isNegative: false, icalclass: "icalduration", icaltype: "duration", clone: function () { return ICAL.Duration.fromData(this) }, toSeconds: function () { var t = this.seconds + 60 * this.minutes + 3600 * this.hours + 86400 * this.days + 7 * 86400 * this.weeks; return this.isNegative ? -t : t }, fromSeconds: function (t) { var n = Math.abs(t); this.isNegative = t < 0; this.days = ICAL.helpers.trunc(n / 86400); if (this.days % 7 == 0) { this.weeks = this.days / 7; this.days = 0 } else { this.weeks = 0 } n -= (this.days + 7 * this.weeks) * 86400; this.hours = ICAL.helpers.trunc(n / 3600); n -= this.hours * 3600; this.minutes = ICAL.helpers.trunc(n / 60); n -= this.minutes * 60; this.seconds = n; return this }, fromData: function (t) { var n = ["weeks", "days", "hours", "minutes", "seconds", "isNegative"]; for (var r in n) { var i = n[r]; if (t && i in t) { this[i] = t[i] } else { this[i] = 0 } } }, reset: function () { this.isNegative = false; this.weeks = 0; this.days = 0; this.hours = 0; this.minutes = 0; this.seconds = 0 }, compare: function (t) { var n = this.toSeconds(); var r = t.toSeconds(); return (n > r) - (n < r) }, normalize: function () { this.fromSeconds(this.toSeconds()); return this }, toString: function n() { if (this.toSeconds() == 0) { return "PT0S" } else { var e = ""; if (this.isNegative) e += "-"; e += "P"; if (this.weeks) e += this.weeks + "W"; if (this.days) e += this.days + "D"; if (this.hours || this.minutes || this.seconds) { e += "T"; if (this.hours) e += this.hours + "H"; if (this.minutes) e += this.minutes + "M"; if (this.seconds) e += this.seconds + "S" } return e } }, toICALString: function () { return this.toString() } }; ICAL.Duration.fromSeconds = function (t) { return (new ICAL.Duration).fromSeconds(t) }; ICAL.Duration.isValueString = function (e) { return e[0] === "P" || e[1] === "P" }, ICAL.Duration.fromString = function (r) { var i = 0; var s = Object.create(null); var o = 0; while ((i = r.search(e)) !== -1) { var u = r[i]; var a = r.substr(0, i); r = r.substr(i + 1); o += t(u, a, s) } if (o < 2) { throw new Error('invalid duration value: Not enough duration components in "' + r + '"') } return new ICAL.Duration(s) }; ICAL.Duration.fromData = function (t) { return new ICAL.Duration(t) } })(); typeof ICAL === "undefined" ? ICAL = {} : ""; (function () { var e = ["tzid", "location", "tznames", "latitude", "longitude"]; ICAL.Timezone = function (t) { this.wrappedJSObject = this; this.fromData(t) }; ICAL.Timezone.prototype = { tzid: "", location: "", tznames: "", latitude: 0, longitude: 0, component: null, expandedUntilYear: 0, icalclass: "icaltimezone", fromData: function (n) { this.expandedUntilYear = 0; this.changes = []; if (n instanceof ICAL.Component) { this.component = n } else { if (n && "component" in n) { if (typeof n.component == "string") { var r = ICAL.parse(n.component); this.component = new ICAL.Component(r[1]) } else if (n.component instanceof ICAL.Component) { this.component = n.component } else { this.component = null } } for (var i in e) { var s = e[i]; if (n && s in n) { this[s] = n[s] } } } if (this.component instanceof ICAL.Component && !this.tzid) { this.tzid = this.component.getFirstPropertyValue("tzid") } return this }, utcOffset: function (t) { if (this == ICAL.Timezone.utcTimezone || this == ICAL.Timezone.localTimezone) { return 0 } this._ensureCoverage(t.year); if (!this.changes.length) { return 0 } var n = { year: t.year, month: t.month, day: t.day, hour: t.hour, minute: t.minute, second: t.second }; var r = this._findNearbyChange(n); var i = -1; var s = 1; for (; ;) { var o = ICAL.helpers.clone(this.changes[r], true); if (o.utcOffset < o.prevUtcOffset) { ICAL.Timezone.adjust_change(o, 0, 0, 0, o.utcOffset) } else { ICAL.Timezone.adjust_change(o, 0, 0, 0, o.prevUtcOffset) } var u = ICAL.Timezone._compare_change_fn(n, o); if (u >= 0) { i = r } else { s = -1 } if (s == -1 && i != -1) { break } r += s; if (r < 0) { return 0 } if (r >= this.changes.length) { break } } var a = this.changes[i]; var f = a.utcOffset - a.prevUtcOffset; if (f < 0 && i > 0) { var l = ICAL.helpers.clone(a, true); ICAL.Timezone.adjust_change(l, 0, 0, 0, l.prevUtcOffset); if (ICAL.Timezone._compare_change_fn(n, l) < 0) { var c = this.changes[i - 1]; var h = false; if (a.is_daylight != h && c.is_daylight == h) { a = c } } } return a.utcOffset }, _findNearbyChange: function (t) { var n = ICAL.helpers.binsearchInsert(this.changes, t, ICAL.Timezone._compare_change_fn); if (n >= this.changes.length) { return this.changes.length - 1 } return n }, _ensureCoverage: function (e) { if (ICAL.Timezone._minimumExpansionYear == -1) { var t = ICAL.Time.now(); ICAL.Timezone._minimumExpansionYear = t.year } var n = e; if (n < ICAL.Timezone._minimumExpansionYear) { n = ICAL.Timezone._minimumExpansionYear } n += ICAL.Timezone.EXTRA_COVERAGE; if (n > ICAL.Timezone.MAX_YEAR) { n = ICAL.Timezone.MAX_YEAR } if (!this.changes.length || this.expandedUntilYear < e) { var r = this.component.getAllSubcomponents(); var i = r.length; var s = 0; for (; s < i; s++) { this._expandComponent(r[s], n, this.changes) } this.changes.sort(ICAL.Timezone._compare_change_fn); this.expandedUntilYear = n } }, _expandComponent: function (e, t, n) { function i(e) { return e.factor * (e.hours * 3600 + e.minutes * 60) } function s() { var t = {}; t.is_daylight = e.name == "daylight"; t.utcOffset = i(e.getFirstProperty("tzoffsetto").getFirstValue()); t.prevUtcOffset = i(e.getFirstProperty("tzoffsetfrom").getFirstValue()); return t } if (!e.hasProperty("dtstart") || !e.hasProperty("tzoffsetto") || !e.hasProperty("tzoffsetfrom")) { return "" } var r = e.getFirstProperty("dtstart").getFirstValue(); if (!e.hasProperty("rrule") && !e.hasProperty("rdate")) { var o = s(); o.year = r.year; o.month = r.month; o.day = r.day; o.hour = r.hour; o.minute = r.minute; o.second = r.second; ICAL.Timezone.adjust_change(o, 0, 0, 0, -o.prevUtcOffset); n.push(o) } else { var u = e.getAllProperties("rdate"); for (var a in u) { var f = u[a]; var l = f.getFirstValue(); var o = s(); o.year = l.year; o.month = l.month; o.day = l.day; if (l.isDate) { o.hour = r.hour; o.minute = r.minute; o.second = r.second; if (r.zone != ICAL.Timezone.utcTimezone) { ICAL.Timezone.adjust_change(o, 0, 0, 0, -o.prevUtcOffset) } } else { o.hour = l.hour; o.minute = l.minute; o.second = l.second; if (l.zone != ICAL.Timezone.utcTimezone) { ICAL.Timezone.adjust_change(o, 0, 0, 0, -o.prevUtcOffset) } } n.push(o) } var c = e.getFirstProperty("rrule"); if (c) { c = c.getFirstValue(); var o = s(); if (c.until && c.until.zone == ICAL.Timezone.utcTimezone) { c.until.adjust(0, 0, 0, o.prevUtcOffset); c.until.zone = ICAL.Timezone.localTimezone } var h = c.iterator(r); var p; while (p = h.next()) { var o = s(); if (p.year > t || !p) { break } o.year = p.year; o.month = p.month; o.day = p.day; o.hour = p.hour; o.minute = p.minute; o.second = p.second; o.isDate = p.isDate; ICAL.Timezone.adjust_change(o, 0, 0, 0, -o.prevUtcOffset); n.push(o) } } } return n }, toString: function t() { return this.tznames ? this.tznames : this.tzid } }; ICAL.Timezone._compare_change_fn = function (t, n) { if (t.year < n.year) return -1; else if (t.year > n.year) return 1; if (t.month < n.month) return -1; else if (t.month > n.month) return 1; if (t.day < n.day) return -1; else if (t.day > n.day) return 1; if (t.hour < n.hour) return -1; else if (t.hour > n.hour) return 1; if (t.minute < n.minute) return -1; else if (t.minute > n.minute) return 1; if (t.second < n.second) return -1; else if (t.second > n.second) return 1; return 0 }; ICAL.Timezone.convert_time = function (t, n, r) { if (t.isDate || n.tzid == r.tzid || n == ICAL.Timezone.localTimezone || r == ICAL.Timezone.localTimezone) { t.zone = r; return t } var i = n.utcOffset(t); t.adjust(0, 0, 0, -i); i = r.utcOffset(t); t.adjust(0, 0, 0, i); return "" }; ICAL.Timezone.fromData = function (t) { var n = new ICAL.Timezone; return n.fromData(t) }; ICAL.Timezone.utcTimezone = ICAL.Timezone.fromData({ tzid: "UTC" }); ICAL.Timezone.localTimezone = ICAL.Timezone.fromData({ tzid: "floating" }); ICAL.Timezone.adjust_change = function (t, n, r, i, s) { return ICAL.Time.prototype.adjust.call(t, n, r, i, s, t) }; ICAL.Timezone._minimumExpansionYear = -1; ICAL.Timezone.MAX_YEAR = 2035; ICAL.Timezone.EXTRA_COVERAGE = 5 })(); ICAL.TimezoneService = function () { var e; var t = { reset: function () { e = Object.create(null); var t = ICAL.Timezone.utcTimezone; e.Z = t; e.UTC = t; e.GMT = t }, has: function (t) { return !!e[t] }, get: function (t) { return e[t] }, register: function (t, n) { if (t instanceof ICAL.Component) { if (t.name === "vtimezone") { n = new ICAL.Timezone(t); t = n.tzid } } if (n instanceof ICAL.Timezone) { e[t] = n } else { throw new TypeError("timezone must be ICAL.Timezone or ICAL.Component") } }, remove: function (t) { return delete e[t] } }; t.reset(); return t }(); typeof ICAL === "undefined" ? ICAL = {} : ""; (function () { ICAL.Time = function (t, n) { this.wrappedJSObject = this; var r = this._time = Object.create(null); r.year = 0; r.month = 1; r.day = 1; r.hour = 0; r.minute = 0; r.second = 0; r.isDate = false; this.fromData(t, n) }; ICAL.Time.prototype = { icalclass: "icaltime", get icaltype() { return this.isDate ? "date" : "date-time" }, zone: null, _pendingNormalization: false, clone: function () { return new ICAL.Time(this._time, this.zone) }, reset: function () { this.fromData(ICAL.Time.epochTime); this.zone = ICAL.Timezone.utcTimezone }, resetTo: function (t, n, r, i, s, o, u) { this.fromData({ year: t, month: n, day: r, hour: i, minute: s, second: o, zone: u }) }, fromString: function (t) { var n; try { n = ICAL.DecorationParser.parseValue(t, "date"); n.isDate = true } catch (r) { n = ICAL.DecorationParser.parseValue(t, "date-time"); n.isDate = false } return this.fromData(n) }, fromJSDate: function (t, n) { if (!t) { this.reset() } else { if (n) { this.zone = ICAL.Timezone.utcTimezone; this.year = t.getUTCFullYear(); this.month = t.getUTCMonth() + 1; this.day = t.getUTCDate(); this.hour = t.getUTCHours(); this.minute = t.getUTCMinutes(); this.second = t.getUTCSeconds() } else { this.zone = ICAL.Timezone.localTimezone; this.year = t.getFullYear(); this.month = t.getMonth() + 1; this.day = t.getDate(); this.hour = t.getHours(); this.minute = t.getMinutes(); this.second = t.getSeconds() } } return this }, fromData: function (t, n) { for (var r in t) { if (r === "icaltype") continue; this[r] = t[r] } if (n) { this.zone = n } if (t && !("isDate" in t)) { this.isDate = !("hour" in t) } else if (t && "isDate" in t) { this.isDate = t.isDate } if (t && "timezone" in t) { var i = ICAL.TimezoneService.get(t.timezone); this.zone = i || ICAL.Timezone.localTimezone } if (t && "zone" in t) { this.zone = t.zone } if (!this.zone) { this.zone = ICAL.Timezone.localTimezone } return this }, dayOfWeek: function () { var t = this.day; var n = this.month + (this.month < 3 ? 12 : 0); var r = this.year - (this.month < 3 ? 1 : 0); var i = t + r + ICAL.helpers.trunc((n + 1) * 26 / 10) + ICAL.helpers.trunc(r / 4); if (true) { i += ICAL.helpers.trunc(r / 100) * 6 + ICAL.helpers.trunc(r / 400) } else { i += 5 } i = (i + 6) % 7 + 1; return i }, dayOfYear: function () { var t = ICAL.Time.is_leap_year(this.year) ? 1 : 0; var n = ICAL.Time._days_in_year_passed_month; return n[t][this.month - 1] + this.day }, startOfWeek: function () { var t = this.clone(); t.day -= this.dayOfWeek() - 1; return t }, endOfWeek: function () { var t = this.clone(); t.day += 7 - this.dayOfWeek(); return t }, startOfMonth: function () { var t = this.clone(); t.day = 1; t.isDate = true; t.hour = 0; t.minute = 0; t.second = 0; return t }, endOfMonth: function () { var t = this.clone(); t.day = ICAL.Time.daysInMonth(t.month, t.year); t.isDate = true; t.hour = 0; t.minute = 0; t.second = 0; return t }, startOfYear: function () { var t = this.clone(); t.day = 1; t.month = 1; t.isDate = true; t.hour = 0; t.minute = 0; t.second = 0; return t }, endOfYear: function () { var t = this.clone(); t.day = 31; t.month = 12; t.isDate = true; t.hour = 0; t.minute = 0; t.second = 0; return t }, startDoyWeek: function (t) { var n = t || ICAL.Time.SUNDAY; var r = this.dayOfWeek() - n; if (r < 0) r += 7; return this.dayOfYear() - r }, nthWeekDay: function (t, n) { var r = ICAL.Time.daysInMonth(this.month, this.year); var i; var s = n; var o = 0; var u = this.clone(); if (s >= 0) { u.day = 1; if (s != 0) { s-- } o = u.day; var a = u.dayOfWeek(); var f = t - a; if (f < 0) f += 7; o += f; o -= t; i = t } else { u.day = r; var l = u.dayOfWeek(); s++; i = l - t; if (i < 0) { i += 7 } i = r - i } i += s * 7; return o + i }, isNthWeekDay: function (e, t) { var n = this.dayOfWeek(); if (t === 0 && n === e) { return true } var r = this.nthWeekDay(e, t); if (r === this.day) { return true } return false }, weekNumber: function (t) { var n = this.dayOfYear(); var r = this.dayOfWeek(); var i = this.year; var s; var o = this.clone(); o.isDate = true; var u = o.dayOfWeek(); var a = this.year; if (o.month == 12 && o.day > 28) { s = ICAL.Time.weekOneStarts(a + 1, t); if (o.compare(s) < 0) { s = ICAL.Time.weekOneStarts(a, t) } else { a++ } } else { s = ICAL.Time.weekOneStarts(a, t); if (o.compare(s) < 0) { s = ICAL.Time.weekOneStarts(--a, t) } } var f = o.subtractDate(s).toSeconds() / 86400; return ICAL.helpers.trunc(f / 7) + 1 }, addDuration: function (t) { var n = t.isNegative ? -1 : 1; var r = this.second; var i = this.minute; var s = this.hour; var o = this.day; r += n * t.seconds; i += n * t.minutes; s += n * t.hours; o += n * t.days; o += n * 7 * t.weeks; this.second = r; this.minute = i; this.hour = s; this.day = o }, subtractDate: function (t) { var n = this.toUnixTime() + this.utcOffset(); var r = t.toUnixTime() + t.utcOffset(); return ICAL.Duration.fromSeconds(n - r) }, subtractDateTz: function (t) { var n = this.toUnixTime(); var r = t.toUnixTime(); return ICAL.Duration.fromSeconds(n - r) }, compare: function (t) { var n = this.toUnixTime(); var r = t.toUnixTime(); if (n > r) return 1; if (r > n) return -1; return 0 }, compareDateOnlyTz: function (t, n) { function r(e) { return ICAL.Time._cmp_attr(i, s, e) } var i = this.convertToZone(n); var s = t.convertToZone(n); var o = 0; if ((o = r("year")) != 0) return o; if ((o = r("month")) != 0) return o; if ((o = r("day")) != 0) return o; return o }, convertToZone: function (t) { var n = this.clone(); var r = this.zone.tzid == t.tzid; if (!this.isDate && !r) { ICAL.Timezone.convert_time(n, this.zone, t) } n.zone = t; return n }, utcOffset: function () { if (this.zone == ICAL.Timezone.localTimezone || this.zone == ICAL.Timezone.utcTimezone) { return 0 } else { return this.zone.utcOffset(this) } }, toICALString: function () { var e = this.toString(); if (e.length > 10) { return ICAL.design.value["date-time"].toICAL(e) } else { return ICAL.design.value.date.toICAL(e) } }, toString: function e() { var e = this.year + "-" + ICAL.helpers.pad2(this.month) + "-" + ICAL.helpers.pad2(this.day); if (!this.isDate) { e += "T" + ICAL.helpers.pad2(this.hour) + ":" + ICAL.helpers.pad2(this.minute) + ":" + ICAL.helpers.pad2(this.second); if (this.zone === ICAL.Timezone.utcTimezone) { e += "Z" } } return e }, toJSDate: function () { if (this.zone == ICAL.Timezone.localTimezone) { if (this.isDate) { return new Date(this.year, this.month - 1, this.day) } else { return new Date(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, 0) } } else { return new Date(this.toUnixTime() * 1e3) } }, _normalize: function () { var t = this._time.isDate; if (this._time.isDate) { this._time.hour = 0; this._time.minute = 0; this._time.second = 0 } this.adjust(0, 0, 0, 0); return this }, adjust: function (t, n, r, i, s) { var o, u, a = 0, f = 0; var l, c, h, p; var d; var v = s || this._time; if (!v.isDate) { l = v.second + i; v.second = l % 60; o = ICAL.helpers.trunc(l / 60); if (v.second < 0) { v.second += 60; o-- } c = v.minute + r + o; v.minute = c % 60; u = ICAL.helpers.trunc(c / 60); if (v.minute < 0) { v.minute += 60; u-- } h = v.hour + n + u; v.hour = h % 24; a = ICAL.helpers.trunc(h / 24); if (v.hour < 0) { v.hour += 24; a-- } } if (v.month > 12) { f = ICAL.helpers.trunc((v.month - 1) / 12) } else if (v.month < 1) { f = ICAL.helpers.trunc(v.month / 12) - 1 } v.year += f; v.month -= 12 * f; p = v.day + t + a; if (p > 0) { for (; ;) { var d = ICAL.Time.daysInMonth(v.month, v.year); if (p <= d) { break } v.month++; if (v.month > 12) { v.year++; v.month = 1 } p -= d } } else { while (p <= 0) { if (v.month == 1) { v.year--; v.month = 12 } else { v.month-- } p += ICAL.Time.daysInMonth(v.month, v.year) } } v.day = p; return this }, fromUnixTime: function (t) { this.zone = ICAL.Timezone.utcTimezone; var n = ICAL.Time.epochTime.clone(); n.adjust(0, 0, 0, t); this.year = n.year; this.month = n.month; this.day = n.day; this.hour = n.hour; this.minute = n.minute; this.second = n.second }, toUnixTime: function () { var t = this.utcOffset(); var n = Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second - t); return n / 1e3 }, toJSON: function () { var e = ["year", "month", "day", "hour", "minute", "second", "isDate"]; var t = Object.create(null); var n = 0; var r = e.length; var i; for (; n < r; n++) { i = e[n]; t[i] = this[i] } if (this.zone) { t.timezone = this.zone.tzid } return t } }; (function () { function t(e) { Object.defineProperty(ICAL.Time.prototype, e, { get: function () { if (this._pendingNormalization) { this._normalize(); this._pendingNormalization = false } return this._time[e] }, set: function (n) { this._pendingNormalization = true; this._time[e] = n; return n } }) } if ("defineProperty" in Object) { t("year"); t("month"); t("day"); t("hour"); t("minute"); t("second"); t("isDate") } })(); ICAL.Time.daysInMonth = function (t, n) { var r = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; var i = 30; if (t < 1 || t > 12) return i; i = r[t]; if (t == 2) { i += ICAL.Time.is_leap_year(n) } return i }; ICAL.Time.is_leap_year = function (t) { if (t <= 1752) { return t % 4 == 0 } else { return t % 4 == 0 && t % 100 != 0 || t % 400 == 0 } }; ICAL.Time.fromDayOfYear = function (t, n) { var r = n; var i = t; var s = new ICAL.Time; s.auto_normalize = false; var o = ICAL.Time.is_leap_year(r) ? 1 : 0; if (i < 1) { r--; o = ICAL.Time.is_leap_year(r) ? 1 : 0; i += ICAL.Time._days_in_year_passed_month[o][12] } else if (i > ICAL.Time._days_in_year_passed_month[o][12]) { o = ICAL.Time.is_leap_year(r) ? 1 : 0; i -= ICAL.Time._days_in_year_passed_month[o][12]; r++ } s.year = r; s.isDate = true; for (var u = 11; u >= 0; u--) { if (i > ICAL.Time._days_in_year_passed_month[o][u]) { s.month = u + 1; s.day = i - ICAL.Time._days_in_year_passed_month[o][u]; break } } s.auto_normalize = true; return s }; ICAL.Time.fromStringv2 = function (t) { return new ICAL.Time({ year: parseInt(t.substr(0, 4), 10), month: parseInt(t.substr(5, 2), 10), day: parseInt(t.substr(8, 2), 10), isDate: true }) }; ICAL.Time.fromDateString = function (e, t) { return new ICAL.Time({ year: ICAL.helpers.strictParseInt(e.substr(0, 4)), month: ICAL.helpers.strictParseInt(e.substr(5, 2)), day: ICAL.helpers.strictParseInt(e.substr(8, 2)), isDate: true }) }; ICAL.Time.fromDateTimeString = function (e, t) { if (e.length < 19) { throw new Error('invalid date-time value: "' + e + '"') } var n; if (e[19] === "Z") { n = "Z" } else if (t) { n = t.getParameter("tzid") } var r = new ICAL.Time({ year: ICAL.helpers.strictParseInt(e.substr(0, 4)), month: ICAL.helpers.strictParseInt(e.substr(5, 2)), day: ICAL.helpers.strictParseInt(e.substr(8, 2)), hour: ICAL.helpers.strictParseInt(e.substr(11, 2)), minute: ICAL.helpers.strictParseInt(e.substr(14, 2)), second: ICAL.helpers.strictParseInt(e.substr(17, 2)), timezone: n }); return r }; ICAL.Time.fromString = function (t) { if (t.length > 10) { return ICAL.Time.fromDateTimeString(t) } else { return ICAL.Time.fromDateString(t) } }; ICAL.Time.fromJSDate = function (t, n) { var r = new ICAL.Time; return r.fromJSDate(t, n) }; ICAL.Time.fromData = function (t) { var n = new ICAL.Time; return n.fromData(t) }; ICAL.Time.now = function () { return ICAL.Time.fromJSDate(new Date, false) }; ICAL.Time.weekOneStarts = function (t, n) { var r = ICAL.Time.fromData({ year: t, month: 1, day: 4, isDate: true }); var i = r.dayOfWeek(); r.day += 1 - i + ((n || ICAL.Time.SUNDAY) - 1); return r }; ICAL.Time.epochTime = ICAL.Time.fromData({ year: 1970, month: 1, day: 1, hour: 0, minute: 0, second: 0, isDate: false, timezone: "Z" }); ICAL.Time._cmp_attr = function (t, n, r) { if (t[r] > n[r]) return 1; if (t[r] < n[r]) return -1; return 0 }; ICAL.Time._days_in_year_passed_month = [[0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365], [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366]]; ICAL.Time.SUNDAY = 1; ICAL.Time.MONDAY = 2; ICAL.Time.TUESDAY = 3; ICAL.Time.WEDNESDAY = 4; ICAL.Time.THURSDAY = 5; ICAL.Time.FRIDAY = 6; ICAL.Time.SATURDAY = 7; ICAL.Time.DEFAULT_WEEK_START = ICAL.Time.MONDAY })(); typeof ICAL === "undefined" ? ICAL = {} : ""; (function () { function i(e, t, n, r) { var i = r; if (r[0] === "+") { i = r.substr(1) } i = ICAL.helpers.strictParseInt(i); if (t !== undefined && r < t) { throw new Error(e + ': invalid value "' + r + '" must be > ' + t) } if (n !== undefined && r > n) { throw new Error(e + ': invalid value "' + r + '" must be < ' + t) } return i } var e = { SU: ICAL.Time.SUNDAY, MO: ICAL.Time.MONDAY, TU: ICAL.Time.TUESDAY, WE: ICAL.Time.WEDNESDAY, TH: ICAL.Time.THURSDAY, FR: ICAL.Time.FRIDAY, SA: ICAL.Time.SATURDAY }; var t = {}; for (var n in e) { t[e[n]] = n } var r = ["BYSECOND", "BYMINUTE", "BYHOUR", "BYDAY", "BYMONTHDAY", "BYYEARDAY", "BYWEEKNO", "BYMONTH", "BYSETPOS"]; ICAL.Recur = function (t) { this.wrappedJSObject = this; this.parts = {}; if (typeof t === "object") { for (var n in t) { this[n] = t[n] } if (this.until && !(this.until instanceof ICAL.Time)) { this.until = new ICAL.Time(this.until) } } if (!this.parts) { this.parts = {} } }; ICAL.Recur.prototype = { parts: null, interval: 1, wkst: ICAL.Time.MONDAY, until: null, count: null, freq: null, icalclass: "icalrecur", icaltype: "recur", iterator: function (e) { return new ICAL.RecurIterator({ rule: this, dtstart: e }) }, clone: function () { return new ICAL.Recur(this.toJSON()) }, isFinite: function () { return !!(this.count || this.until) }, isByCount: function () { return !!(this.count && !this.until) }, addComponent: function (t, n) { if (!(t in this.parts)) { this.parts[t] = [n] } else { this.parts[t].push(n) } }, setComponent: function (t, n) { this.parts[t] = n }, getComponent: function (t, n) { var r = t.toUpperCase(); var i = r in this.parts ? this.parts[r] : []; if (n) n.value = i.length; return i }, getNextOccurrence: function (t, n) { var r = this.iterator(t); var i, s; do { i = r.next() } while (i && i.compare(n) <= 0); if (i && n.zone) { i.zone = n.zone } return i }, toJSON: function () { var e = ["freq", "count", "until", "wkst", "interval", "parts"]; var t = Object.create(null); var n = 0; var r = e.length; var i; for (; n < r; n++) { var i = e[n]; t[i] = this[i] } if (t.until instanceof ICAL.Time) { t.until = t.until.toJSON() } return t }, toString: function () { var t = "FREQ=" + this.freq; if (this.count) { t += ";COUNT=" + this.count } if (this.interval > 1) { t += ";INTERVAL=" + this.interval } for (var n in this.parts) { t += ";" + n + "=" + this.parts[n] } if (this.until) { t += ";UNTIL=" + this.until.toString() } if ("wkst" in this && this.wkst !== ICAL.Time.DEFAULT_WEEK_START) { t += ";WKST=" + ICAL.Recur.numericDayToIcalDay(this.wkst) } return t } }; ICAL.Recur.icalDayToNumericDay = function (n) { return e[n] }; ICAL.Recur.numericDayToIcalDay = function (n) { return t[n] }; var s = /^(SU|MO|TU|WE|TH|FR|SA)$/; var o = /^([+-])?(5[0-3]|[1-4][0-9]|[1-9])?(SU|MO|TU|WE|TH|FR|SA)$/; var u = ["SECONDLY", "MINUTELY", "HOURLY", "DAILY", "WEEKLY", "MONTHLY", "YEARLY"]; var a = { FREQ: function (e, t) { if (u.indexOf(e) !== -1) { t.freq = e } else { throw new Error('invalid frequency "' + e + '" expected: "' + u.join(", ") + '"') } }, COUNT: function (e, t) { t.count = ICAL.helpers.strictParseInt(e) }, INTERVAL: function (e, t) { t.interval = ICAL.helpers.strictParseInt(e); if (t.interval < 1) { t.interval = 1 } }, UNTIL: function (e, t) { t.until = ICAL.Time.fromString(e) }, WKST: function (e, t) { if (s.test(e)) { t.wkst = ICAL.Recur.icalDayToNumericDay(e) } else { throw new Error('invalid WKST value "' + e + '"') } } }; var f = { BYSECOND: i.bind(this, "BYSECOND", 0, 60), BYMINUTE: i.bind(this, "BYMINUTE", 0, 59), BYHOUR: i.bind(this, "BYHOUR", 0, 23), BYDAY: function (e) { if (o.test(e)) { return e } else { throw new Error('invalid BYDAY value "' + e + '"') } }, BYMONTHDAY: i.bind(this, "BYMONTHDAY", -31, 31), BYYEARDAY: i.bind(this, "BYYEARDAY", -366, 366), BYWEEKNO: i.bind(this, "BYWEEKNO", -53, 53), BYMONTH: i.bind(this, "BYMONTH", 0, 12), BYSETPOS: i.bind(this, "BYSETPOS", -366, 366) }; ICAL.Recur.fromString = function (e) { var t = Object.create(null); var n = t.parts = Object.create(null); var r = e.split(";"); var i = r.length; for (var s = 0; s < i; s++) { var o = r[s].split("="); var u = o[0]; var l = o[1]; if (u in f) { var c = l.split(","); var h = 0; var p = c.length; for (; h < p; h++) { c[h] = f[u](c[h]) } n[u] = c } else if (u in a) { a[u](l, t) } } return new ICAL.Recur(t) } })(); ICAL.RecurIterator = function () { function e(e) { this.fromData(e) } e.prototype = { completed: false, rule: null, dtstart: null, last: null, occurrence_number: 0, by_indices: null, initialized: false, by_data: null, days: null, days_index: 0, fromData: function (e) { this.rule = ICAL.helpers.formatClassType(e.rule, ICAL.Recur); if (!this.rule) { throw new Error("iterator requires a (ICAL.Recur) rule") } this.dtstart = ICAL.helpers.formatClassType(e.dtstart, ICAL.Time); if (!this.dtstart) { throw new Error("iterator requires a (ICAL.Time) dtstart") } if (e.by_data) { this.by_data = e.by_data } else { this.by_data = ICAL.helpers.clone(this.rule.parts, true) } if (e.occurrence_number) this.occurrence_number = e.occurrence_number; this.days = e.days || []; this.last = ICAL.helpers.formatClassType(e.last, ICAL.Time); this.by_indices = e.by_indices; if (!this.by_indices) { this.by_indices = { BYSECOND: 0, BYMINUTE: 0, BYHOUR: 0, BYDAY: 0, BYMONTH: 0, BYWEEKNO: 0, BYMONTHDAY: 0 } } this.initialized = e.initialized || false; if (!this.initialized) { this.init() } }, init: function () { this.initialized = true; this.last = this.dtstart.clone(); var t = this.by_data; if ("BYDAY" in t) { this.sort_byday_rules(t.BYDAY, this.rule.wkst) } if ("BYYEARDAY" in t) { if ("BYMONTH" in t || "BYWEEKNO" in t || "BYMONTHDAY" in t || "BYDAY" in t) { throw new Error("Invalid BYYEARDAY rule") } } if ("BYWEEKNO" in t && "BYMONTHDAY" in t) { throw new Error("BYWEEKNO does not fit to BYMONTHDAY") } if (this.rule.freq == "MONTHLY" && ("BYYEARDAY" in t || "BYWEEKNO" in t)) { throw new Error("For MONTHLY recurrences neither BYYEARDAY nor BYWEEKNO may appear") } if (this.rule.freq == "WEEKLY" && ("BYYEARDAY" in t || "BYMONTHDAY" in t)) { throw new Error("For WEEKLY recurrences neither BYMONTHDAY nor BYYEARDAY may appear") } if (this.rule.freq != "YEARLY" && "BYYEARDAY" in t) { throw new Error("BYYEARDAY may only appear in YEARLY rules") } this.last.second = this.setup_defaults("BYSECOND", "SECONDLY", this.dtstart.second); this.last.minute = this.setup_defaults("BYMINUTE", "MINUTELY", this.dtstart.minute); this.last.hour = this.setup_defaults("BYHOUR", "HOURLY", this.dtstart.hour); this.last.day = this.setup_defaults("BYMONTHDAY", "DAILY", this.dtstart.day); this.last.month = this.setup_defaults("BYMONTH", "MONTHLY", this.dtstart.month); if (this.rule.freq == "WEEKLY") { if ("BYDAY" in t) { var t = this.ruleDayOfWeek(t.BYDAY[0]); var n = t[0]; var r = t[1]; var i = r - this.last.dayOfWeek(); if (this.last.dayOfWeek() < r && i >= 0 || i < 0) { this.last.day += i } } else { var s = ICAL.Recur.numericDayToIcalDay(this.dtstart.dayOfWeek()); t.BYDAY = [s] } } if (this.rule.freq == "YEARLY") { for (; ;) { this.expand_year_days(this.last.year); if (this.days.length > 0) { break } this.increment_year(this.rule.interval) } var o = ICAL.Time.fromDayOfYear(this.days[0], this.last.year); this.last.day = o.day; this.last.month = o.month } if (this.rule.freq == "MONTHLY" && this.has_by_data("BYDAY")) { var u = this.by_data.BYDAY[this.by_indices.BYDAY]; var t = this.ruleDayOfWeek(u); var n = t[0]; var i = t[1]; var a = ICAL.Time.daysInMonth(this.last.month, this.last.year); var f = 0; if (n >= 0) { for (this.last.day = 1; this.last.day <= a; this.last.day++) { if (this.last.dayOfWeek() == i) { if (++f == n || n == 0) { break } } } } else { n = -n; for (this.last.day = a; this.last.day != 0; this.last.day--) { if (this.last.dayOfWeek() == i) { if (++f == n) { break } } } } if (this.has_by_data("BYMONTHDAY")) { this._byDayAndMonthDay(true) } if (this.last.day > a || this.last.day == 0) { throw new Error("Malformed values in BYDAY part") } } else if (this.has_by_data("BYMONTHDAY")) { if (this.last.day < 0) { var a = ICAL.Time.daysInMonth(this.last.month, this.last.year); this.last.day = a + this.last.day + 1 } } }, next: function () { var t = this.last ? this.last.clone() : null; if (this.rule.count && this.occurrence_number >= this.rule.count || this.rule.until && this.last.compare(this.rule.until) > 0) { this.completed = true; return "" } if (this.occurrence_number == 0 && this.last.compare(this.dtstart) >= 0) { this.occurrence_number++; return this.last } do { var n = 1; switch (this.rule.freq) { case "SECONDLY": this.next_second(); break; case "MINUTELY": this.next_minute(); break; case "HOURLY": this.next_hour(); break; case "DAILY": this.next_day(); break; case "WEEKLY": this.next_week(); break; case "MONTHLY": n = this.next_month(); break; case "YEARLY": this.next_year(); break; default: return "" } } while (!this.check_contracting_rules() || this.last.compare(this.dtstart) < 0 || !n); if (this.last.compare(t) == 0) { throw new Error("Same occurrence found twice, protecting " + "you from death by recursion") } if (this.rule.until && this.last.compare(this.rule.until) > 0) { this.completed = true; return "" } else { this.occurrence_number++; return this.last } }, next_second: function () { return this.next_generic("BYSECOND", "SECONDLY", "second", "minute") }, increment_second: function (t) { return this.increment_generic(t, "second", 60, "minute") }, next_minute: function () { return this.next_generic("BYMINUTE", "MINUTELY", "minute", "hour", "next_second") }, increment_minute: function (t) { return this.increment_generic(t, "minute", 60, "hour") }, next_hour: function () { return this.next_generic("BYHOUR", "HOURLY", "hour", "monthday", "next_minute") }, increment_hour: function (t) { this.increment_generic(t, "hour", 24, "monthday") }, next_day: function () { var t = "BYDAY" in this.by_data; var n = this.rule.freq == "DAILY"; if (this.next_hour() == 0) { return 0 } if (n) { this.increment_monthday(this.rule.interval) } else { this.increment_monthday(1) } return 0 }, next_week: function () { var t = 0; if (this.next_weekday_by_week() == 0) { return t } if (this.has_by_data("BYWEEKNO")) { var n = ++this.by_indices.BYWEEKNO; if (this.by_indices.BYWEEKNO == this.by_data.BYWEEKNO.length) { this.by_indices.BYWEEKNO = 0; t = 1 } this.last.month = 1; this.last.day = 1; var r = this.by_data.BYWEEKNO[this.by_indices.BYWEEKNO]; this.last.day += 7 * r; if (t) { this.increment_year(1) } } else { this.increment_monthday(7 * this.rule.interval) } return t }, normalizeByMonthDayRules: function (e, t, n) { var r = ICAL.Time.daysInMonth(t, e); var i = []; var s = 0; var o = n.length; var u; for (; s < o; s++) { u = n[s]; if (Math.abs(u) > r) { continue } if (u < 0) { u = r + (u + 1) } else if (u === 0) { continue } if (i.indexOf(u) === -1) { i.push(u) } } return i.sort(function (e, t) { return e - t }) }, _byDayAndMonthDay: function (e) { function c() { a = ICAL.Time.daysInMonth(f.last.month, f.last.year); t = f.normalizeByMonthDayRules(f.last.year, f.last.month, f.by_data.BYMONTHDAY); s = t.length; while (t[i] <= l && i < s - 1) { i++ } } function h() { l = 0; f.increment_month(); i = 0; c() } var t; var n = this.by_data.BYDAY; var r; var i = 0; var s; var o = n.length; var u = 0; var a; var f = this; var l = this.last.day; c(); if (e) { l -= 1 } while (!u) { r = l + 1; if (r > a) { h(); continue } var p = t[i++]; if (p >= r) { l = p } else { h(); continue } for (var d = 0; d < o; d++) { var v = this.ruleDayOfWeek(n[d]); var m = v[0]; var g = v[1]; this.last.day = l; if (this.last.isNthWeekDay(g, m)) { u = 1; break } } if (!u && i === s) { h(); continue } } return u }, next_month: function () { var t = this.rule.freq == "MONTHLY"; var n = 1; if (this.next_hour() == 0) { return n } if (this.has_by_data("BYDAY") && this.has_by_data("BYMONTHDAY")) { n = this._byDayAndMonthDay() } else if (this.has_by_data("BYDAY")) { var r = ICAL.Time.daysInMonth(this.last.month, this.last.year); var i = 0; if (this.has_by_data("BYSETPOS")) { var s = this.last.day; for (var o = 1; o <= r; o++) { this.last.day = o; if (this.is_day_in_byday(this.last) && o <= s) { i++ } } this.last.day = s } for (var o = this.last.day + 1; o <= r; o++) { this.last.day = o; if (this.is_day_in_byday(this.last)) { if (!this.has_by_data("BYSETPOS") || this.check_set_position(++i) || this.check_set_position(i - this.by_data.BYSETPOS.length - 1)) { n = 1; break } } } if (o > r) { this.last.day = 1; this.increment_month(); if (this.is_day_in_byday(this.last)) { if (!this.has_by_data("BYSETPOS") || this.check_set_position(1)) { n = 1 } } else { n = 0 } } } else if (this.has_by_data("BYMONTHDAY")) { this.by_indices.BYMONTHDAY++; if (this.by_indices.BYMONTHDAY >= this.by_data.BYMONTHDAY.length) { this.by_indices.BYMONTHDAY = 0; this.increment_month() } var r = ICAL.Time.daysInMonth(this.last.month, this.last.year); var o = this.by_data.BYMONTHDAY[this.by_indices.BYMONTHDAY]; if (o < 0) { o = r + o + 1 } if (o > r) { this.last.day = 1; n = this.is_day_in_byday(this.last) } else { this.last.day = o } } else { this.last.day = this.by_data.BYMONTHDAY[0]; this.increment_month(); var r = ICAL.Time.daysInMonth(this.last.month, this.last.year); this.last.day = Math.min(this.last.day, r) } return n }, next_weekday_by_week: function () { var t = 0; if (this.next_hour() == 0) { return t } if (!this.has_by_data("BYDAY")) { return 1 } for (; ;) { var n = new ICAL.Time; this.by_indices.BYDAY++; if (this.by_indices.BYDAY == Object.keys(this.by_data.BYDAY).length) { this.by_indices.BYDAY = 0; t = 1 } var r = this.by_data.BYDAY[this.by_indices.BYDAY]; var i = this.ruleDayOfWeek(r); var s = i[1]; s -= this.rule.wkst; if (s < 0) { s += 7 } n.year = this.last.year; n.month = this.last.month; n.day = this.last.day; var o = n.startDoyWeek(this.rule.wkst); if (s + o < 1) { if (!t) { continue } } var u = ICAL.Time.fromDayOfYear(o + s, this.last.year); this.last.year = u.year; this.last.month = u.month; this.last.day = u.day; return t } }, next_year: function () { if (this.next_hour() == 0) { return 0 } if (++this.days_index == this.days.length) { this.days_index = 0; do { this.increment_year(this.rule.interval); this.expand_year_days(this.last.year) } while (this.days.length == 0) } var t = ICAL.Time.fromDayOfYear(this.days[this.days_index], this.last.year); this.last.day = t.day; this.last.month = t.month; return 1 }, ruleDayOfWeek: function (t) { var n = t.match(/([+-]?[0-9])?(MO|TU|WE|TH|FR|SA|SU)/); if (n) { var r = parseInt(n[1] || 0, 10); t = ICAL.Recur.icalDayToNumericDay(n[2]); return [r, t] } else { return [0, 0] } }, next_generic: function (t, n, r, i, s) { var o = t in this.by_data; var u = this.rule.freq == n; var a = 0; if (s && this[s]() == 0) { return a } if (o) { this.by_indices[t]++; var f = this.by_indices[t]; var l = this.by_data[t]; if (this.by_indices[t] == l.length) { this.by_indices[t] = 0; a = 1 } this.last[r] = l[this.by_indices[t]] } else if (u) { this["increment_" + r](this.rule.interval) } if (o && a && u) { this["increment_" + i](1) } return a }, increment_monthday: function (t) { for (var n = 0; n < t; n++) { var r = ICAL.Time.daysInMonth(this.last.month, this.last.year); this.last.day++; if (this.last.day > r) { this.last.day -= r; this.increment_month() } } }, increment_month: function () { this.last.day = 1; if (this.has_by_data("BYMONTH")) { this.by_indices.BYMONTH++; if (this.by_indices.BYMONTH == this.by_data.BYMONTH.length) { this.by_indices.BYMONTH = 0; this.increment_year(1) } this.last.month = this.by_data.BYMONTH[this.by_indices.BYMONTH] } else { if (this.rule.freq == "MONTHLY") { this.last.month += this.rule.interval } else { this.last.month++ } this.last.month--; var t = ICAL.helpers.trunc(this.last.month / 12); this.last.month %= 12; this.last.month++; if (t != 0) { this.increment_year(t) } } }, increment_year: function (t) { this.last.year += t }, increment_generic: function (t, n, r, i) { this.last[n] += t; var s = ICAL.helpers.trunc(this.last[n] / r); this.last[n] %= r; if (s != 0) { this["increment_" + i](s) } }, has_by_data: function (t) { return t in this.rule.parts }, expand_year_days: function (t) { var n = new ICAL.Time; this.days = []; var r = {}; var i = ["BYDAY", "BYWEEKNO", "BYMONTHDAY", "BYMONTH", "BYYEARDAY"]; for (var s in i) { var o = i[s]; if (o in this.rule.parts) { r[o] = this.rule.parts[o] } } if ("BYMONTH" in r && "BYWEEKNO" in r) { var u = 1; var a = {}; n.year = t; n.isDate = true; for (var f = 0; f < this.by_data.BYMONTH.length; f++) { var l = this.by_data.BYMONTH[f]; n.month = l; n.day = 1; var c = n.weekNumber(this.rule.wkst); n.day = ICAL.Time.daysInMonth(l, t); var h = n.weekNumber(this.rule.wkst); for (f = c; f < h; f++) { a[f] = 1 } } for (var p = 0; p < this.by_data.BYWEEKNO.length && u; p++) { var d = this.by_data.BYWEEKNO[p]; if (d < 52) { u &= a[p] } else { u = 0 } } if (u) { delete r.BYMONTH } else { delete r.BYWEEKNO } } var v = Object.keys(r).length; if (v == 0) { var n = this.dtstart.clone(); n.year = this.last.year; this.days.push(n.dayOfYear()) } else if (v == 1 && "BYMONTH" in r) { for (var m in this.by_data.BYMONTH) { var g = this.dtstart.clone(); g.year = t; g.month = this.by_data.BYMONTH[m]; g.isDate = true; this.days.push(g.dayOfYear()) } } else if (v == 1 && "BYMONTHDAY" in r) { for (var y in this.by_data.BYMONTHDAY) { var g = this.dtstart.clone(); g.day = this.by_data.BYMONTHDAY[y]; g.year = t; g.isDate = true; this.days.push(g.dayOfYear()) } } else if (v == 2 && "BYMONTHDAY" in r && "BYMONTH" in r) { for (var m in this.by_data.BYMONTH) { for (var y in this.by_data.BYMONTHDAY) { n.day = this.by_data.BYMONTHDAY[y]; n.month = this.by_data.BYMONTH[m]; n.year = t; n.isDate = true; this.days.push(n.dayOfYear()) } } } else if (v == 1 && "BYWEEKNO" in r) { } else if (v == 2 && "BYWEEKNO" in r && "BYMONTHDAY" in r) { } else if (v == 1 && "BYDAY" in r) { this.days = this.days.concat(this.expand_by_day(t)) } else if (v == 2 && "BYDAY" in r && "BYMONTH" in r) { for (var m in this.by_data.BYMONTH) { l = this.by_data.BYMONTH[m]; var b = ICAL.Time.daysInMonth(l, t); n.year = t; n.month = this.by_data.BYMONTH[m]; n.day = 1; n.isDate = true; var w = n.dayOfWeek(); var E = n.dayOfYear() - 1; n.day = b; var S = n.dayOfWeek(); if (this.has_by_data("BYSETPOS")) { var x = 0; var T = []; for (var N = 1; N <= b; N++) { n.day = N; if (this.is_day_in_byday(n)) { T.push(N) } } for (var C = 0; C < T.length; C++) { if (this.check_set_position(C + 1) || this.check_set_position(C - T.length)) { this.days.push(E + T[C]) } } } else { for (var k in this.by_data.BYDAY) { var L = this.by_data.BYDAY[k]; var r = this.ruleDayOfWeek(L); var A = r[0]; var O = r[1]; var M; var _ = (O + 7 - w) % 7 + 1; var D = b - (S + 7 - O) % 7; if (A == 0) { for (var N = _; N <= b; N += 7) { this.days.push(E + N) } } else if (A > 0) { M = _ + (A - 1) * 7; if (M <= b) { this.days.push(E + M) } } else { M = D + (A + 1) * 7; if (M > 0) { this.days.push(E + M) } } } } } } else if (v == 2 && "BYDAY" in r && "BYMONTHDAY" in r) { var P = this.expand_by_day(t); for (var H in P) { var N = P[H]; var B = ICAL.Time.fromDayOfYear(N, t); if (this.by_data.BYMONTHDAY.indexOf(B.day) >= 0) { this.days.push(N) } } } else if (v == 3 && "BYDAY" in r && "BYMONTHDAY" in r && "BYMONTH" in r) { var P = this.expand_by_day(t); for (var H in P) { var N = P[H]; var B = ICAL.Time.fromDayOfYear(N, t); if (this.by_data.BYMONTH.indexOf(B.month) >= 0 && this.by_data.BYMONTHDAY.indexOf(B.day) >= 0) { this.days.push(N) } } } else if (v == 2 && "BYDAY" in r && "BYWEEKNO" in r) { var P = this.expand_by_day(t); for (var H in P) { var N = P[H]; var B = ICAL.Time.fromDayOfYear(N, t); var d = B.weekNumber(this.rule.wkst); if (this.by_data.BYWEEKNO.indexOf(d)) { this.days.push(N) } } } else if (v == 3 && "BYDAY" in r && "BYWEEKNO" in r && "BYMONTHDAY" in r) { } else if (v == 1 && "BYYEARDAY" in r) { this.days = this.days.concat(this.by_data.BYYEARDAY) } else { this.days = [] } return 0 }, expand_by_day: function (t) { var n = []; var r = this.last.clone(); r.year = t; r.month = 1; r.day = 1; r.isDate = true; var i = r.dayOfWeek(); r.month = 12; r.day = 31; r.isDate = true; var s = r.dayOfWeek(); var o = r.dayOfYear(); for (var u in this.by_data.BYDAY) { var a = this.by_data.BYDAY[u]; var f = this.ruleDayOfWeek(a); var l = f[0]; var c = f[1]; if (l == 0) { var h = (c + 7 - i) % 7 + 1; for (var p = h; p <= o; p += 7) { n.push(p) } } else if (l > 0) { var d; if (c >= i) { d = c - i + 1 } else { d = c - i + 8 } n.push(d + (l - 1) * 7) } else { var v; l = -l; if (c <= s) { v = o - s + c } else { v = o - s + c - 7 } n.push(v - (l - 1) * 7) } } return n }, is_day_in_byday: function (t) { for (var n in this.by_data.BYDAY) { var r = this.by_data.BYDAY[n]; var i = this.ruleDayOfWeek(r); var s = i[0]; var o = i[1]; var u = t.dayOfWeek(); if (s == 0 && o == u || t.nthWeekDay(o, s) == t.day) { return 1 } } return 0 }, check_set_position: function (t) { if (this.has_by_data("BYSETPOS")) { var n = this.by_data.BYSETPOS.indexOf(t); return n !== -1 } return false }, sort_byday_rules: function (t, n) { for (var r = 0; r < t.length; r++) { for (var i = 0; i < r; i++) { var s = this.ruleDayOfWeek(t[i])[1]; var o = this.ruleDayOfWeek(t[r])[1]; s -= n; o -= n; if (s < 0) s += 7; if (o < 0) o += 7; if (s > o) { var u = t[r]; t[r] = t[i]; t[i] = u } } } }, check_contract_restriction: function (n, r) { var i = e._indexMap[n]; var s = e._expandMap[this.rule.freq][i]; var o = false; if (n in this.by_data && s == e.CONTRACT) { var u = this.by_data[n]; for (var a in u) { if (u[a] == r) { o = true; break } } } else { o = true } return o }, check_contracting_rules: function () { var t = this.last.dayOfWeek(); var n = this.last.weekNumber(this.rule.wkst); var r = this.last.dayOfYear(); return this.check_contract_restriction("BYSECOND", this.last.second) && this.check_contract_restriction("BYMINUTE", this.last.minute) && this.check_contract_restriction("BYHOUR", this.last.hour) && this.check_contract_restriction("BYDAY", ICAL.Recur.numericDayToIcalDay(t)) && this.check_contract_restriction("BYWEEKNO", n) && this.check_contract_restriction("BYMONTHDAY", this.last.day) && this.check_contract_restriction("BYMONTH", this.last.month) && this.check_contract_restriction("BYYEARDAY", r) }, setup_defaults: function (n, r, i) { var s = e._indexMap[n]; var o = e._expandMap[this.rule.freq][s]; if (o != e.CONTRACT) { if (!(n in this.by_data)) { this.by_data[n] = [i] } if (this.rule.freq != r) { return this.by_data[n][0] } } return i }, toJSON: function () { var e = Object.create(null); e.initialized = this.initialized; e.rule = this.rule.toJSON(); e.dtstart = this.dtstart.toJSON(); e.by_data = this.by_data; e.days = this.days; e.last = this.last.toJSON(); e.by_indices = this.by_indices; e.occurrence_number = this.occurrence_number; return e } }; e._indexMap = { BYSECOND: 0, BYMINUTE: 1, BYHOUR: 2, BYDAY: 3, BYMONTHDAY: 4, BYYEARDAY: 5, BYWEEKNO: 6, BYMONTH: 7, BYSETPOS: 8 }; e._expandMap = { SECONDLY: [1, 1, 1, 1, 1, 1, 1, 1], MINUTELY: [2, 1, 1, 1, 1, 1, 1, 1], HOURLY: [2, 2, 1, 1, 1, 1, 1, 1], DAILY: [2, 2, 2, 1, 1, 1, 1, 1], WEEKLY: [2, 2, 2, 2, 3, 3, 1, 1], MONTHLY: [2, 2, 2, 2, 2, 3, 3, 1], YEARLY: [2, 2, 2, 2, 2, 2, 2, 2] }; e.UNKNOWN = 0; e.CONTRACT = 1; e.EXPAND = 2; e.ILLEGAL = 3; return e }(); ICAL.RecurExpansion = function () { function e(e) { return ICAL.helpers.formatClassType(e, ICAL.Time) } function t(e, t) { return e.compare(t) } function n(e) { return e.hasProperty("rdate") || e.hasProperty("rrule") || e.hasProperty("recurrence-id") } function r(e) { this.ruleDates = []; this.exDates = []; this.fromData(e) } r.prototype = { complete: false, ruleIterators: null, ruleDates: null, exDates: null, ruleDateInc: 0, exDateInc: 0, exDate: null, ruleDate: null, dtstart: null, last: null, fromData: function (t) { var n = ICAL.helpers.formatClassType(t.dtstart, ICAL.Time); if (!n) { throw new Error(".dtstart (ICAL.Time) must be given") } else { this.dtstart = n } if (t.component) { this._init(t.component) } else { this.last = e(t.last); this.ruleIterators = t.ruleIterators.map(function (e) { return ICAL.helpers.formatClassType(e, ICAL.RecurIterator) }); this.ruleDateInc = t.ruleDateInc; this.exDateInc = t.exDateInc; if (t.ruleDates) { this.ruleDates = t.ruleDates.map(e); this.ruleDate = this.ruleDates[this.ruleDateInc] } if (t.exDates) { this.exDates = t.exDates.map(e); this.exDate = this.exDates[this.exDateInc] } if (typeof t.complete !== "undefined") { this.complete = t.complete } } }, next: function () { var e; var t; var n; var r; var i = 500; var s = 0; while (true) { if (s++ > i) { throw new Error("max tries have occured, rule may be impossible to forfill.") } n = this.ruleDate; e = this._nextRecurrenceIter(this.last); if (!n && !e) { this.complete = true; break } if (!n || e && n.compare(e.last) > 0) { n = e.last.clone(); e.next() } if (this.ruleDate === n) { this._nextRuleDay() } this.last = n; if (this.exDate) { r = this.exDate.compare(this.last); if (r < 0) { this._nextExDay() } if (r === 0) { this._nextExDay(); continue } } return this.last } }, toJSON: function () { function e(e) { return e.toJSON() } var t = Object.create(null); t.ruleIterators = this.ruleIterators.map(e); if (this.ruleDates) { t.ruleDates = this.ruleDates.map(e) } if (this.exDates) { t.exDates = this.exDates.map(e) } t.ruleDateInc = this.ruleDateInc; t.exDateInc = this.exDateInc; t.last = this.last.toJSON(); t.dtstart = this.dtstart.toJSON(); t.complete = this.complete; return t }, _extractDates: function (e, n) { var r = []; var i = e.getAllProperties(n); var s = i.length; var o = 0; var u; var a; for (; o < s; o++) { i[o].getValues().forEach(function (e) { a = ICAL.helpers.binsearchInsert(r, e, t); r.splice(a, 0, e) }) } return r }, _init: function (e) { this.ruleIterators = []; this.last = this.dtstart.clone(); if (!n(e)) { this.ruleDate = this.last.clone(); this.complete = true; return } if (e.hasProperty("rdate")) { this.ruleDates = this._extractDates(e, "rdate"); if (this.ruleDates[0] && this.ruleDates[0].compare(this.dtstart) < 0) { this.ruleDateInc = 0; this.last = this.ruleDates[0].clone() } else { this.ruleDateInc = ICAL.helpers.binsearchInsert(this.ruleDates, this.last, t) } this.ruleDate = this.ruleDates[this.ruleDateInc] } if (e.hasProperty("rrule")) { var r = e.getAllProperties("rrule"); var i = 0; var s = r.length; var o; var u; for (; i < s; i++) { o = r[i].getFirstValue(); u = o.iterator(this.dtstart); this.ruleIterators.push(u); u.next() } } if (e.hasProperty("exdate")) { this.exDates = this._extractDates(e, "exdate"); this.exDateInc = ICAL.helpers.binsearchInsert(this.exDates, this.last, t); this.exDate = this.exDates[this.exDateInc] } }, _nextExDay: function () { this.exDate = this.exDates[++this.exDateInc] }, _nextRuleDay: function () { this.ruleDate = this.ruleDates[++this.ruleDateInc] }, _nextRecurrenceIter: function () { var e = this.ruleIterators; if (e.length === 0) { return "" } var t = e.length; var n; var r; var i = 0; var s; for (; i < t; i++) { n = e[i]; r = n.last; if (n.completed) { t--; if (i !== 0) { i-- } e.splice(i, 1); continue } if (!s || s.last.compare(r) > 0) { s = n } } return s } }; return r }(); ICAL.Event = function () { function e(e, t) { if (e[0] > t[0]) return 1; if (t[0] > e[0]) return -1; return 0 } function t(e, t) { if (!(e instanceof ICAL.Component)) { t = e; e = null } if (e) { this.component = e } else { this.component = new ICAL.Component("vevent") } this._rangeExceptionCache = Object.create(null); this.exceptions = Object.create(null); this.rangeExceptions = []; if (t && t.strictExceptions) { this.strictExceptions = t.strictExceptions } if (t && t.exceptions) { t.exceptions.forEach(this.relateException, this) } } t.prototype = { THISANDFUTURE: "THISANDFUTURE", exceptions: null, strictExceptions: false, relateException: function (t) { if (this.isRecurrenceException()) { throw new Error("cannot relate exception to exceptions") } if (t instanceof ICAL.Component) { t = new ICAL.Event(t) } if (this.strictExceptions && t.uid !== this.uid) { throw new Error("attempted to relate unrelated exception") } var n = t.recurrenceId.toString(); this.exceptions[n] = t; if (t.modifiesFuture()) { var r = [t.recurrenceId.toUnixTime(), n]; var i = ICAL.helpers.binsearchInsert(this.rangeExceptions, r, e); this.rangeExceptions.splice(i, 0, r) } }, modifiesFuture: function () { var e = this.component.getFirstPropertyValue("range"); return e === this.THISANDFUTURE }, findRangeException: function (t) { if (!this.rangeExceptions.length) { return "" } var n = t.toUnixTime(); var r = ICAL.helpers.binsearchInsert(this.rangeExceptions, [n], e); r -= 1; if (r < 0) { return "" } var i = this.rangeExceptions[r]; if (n < i[0]) { return "" } return i[1] }, getOccurrenceDetails: function (e) { var t = e.toString(); var n = e.convertToZone(ICAL.Timezone.utcTimezone).toString(); var r = { recurrenceId: e }; if (t in this.exceptions) { var i = r.item = this.exceptions[t]; r.startDate = i.startDate; r.endDate = i.endDate; r.item = i } else if (n in this.exceptions) { var i = this.exceptions[n]; r.startDate = i.startDate; r.endDate = i.endDate; r.item = i } else { var s = this.findRangeException(e); if (s) { var o = this.exceptions[s]; r.item = o; var u = this._rangeExceptionCache[s]; if (!u) { var a = o.recurrenceId.clone(); var f = o.startDate.clone(); a.zone = f.zone; var u = f.subtractDate(a); this._rangeExceptionCache[s] = u } var l = e.clone(); l.zone = o.startDate.zone; l.addDuration(u); var c = l.clone(); c.addDuration(o.duration); r.startDate = l; r.endDate = c } else { var c = e.clone(); c.addDuration(this.duration); r.endDate = c; r.startDate = e; r.item = this } } return r }, iterator: function (e) { return new ICAL.RecurExpansion({ component: this.component, dtstart: e || this.startDate }) }, isRecurring: function () { var e = this.component; return e.hasProperty("rrule") || e.hasProperty("rdate") }, isRecurrenceException: function () { return this.component.hasProperty("recurrence-id") }, getRecurrenceTypes: function () { var e = this.component.getAllProperties("rrule"); var t = 0; var n = e.length; var r = Object.create(null); for (; t < n; t++) { var i = e[t].getFirstValue(); r[i.freq] = true } return r }, get uid() { return this._firstProp("uid") }, set uid(e) { this._setProp("uid", e) }, get startDate() { return this._firstProp("dtstart") }, set startDate(e) { this._setTime("dtstart", e) }, get endDate() { return this._firstProp("dtend") }, set endDate(e) { this._setTime("dtend", e) }, get duration() { return this.endDate.subtractDate(this.startDate) }, get location() { return this._firstProp("location") }, set location(e) { return this._setProp("location", e) }, get attendees() { return this.component.getAllProperties("attendee") }, get summary() { return this._firstProp("summary") }, set summary(e) { this._setProp("summary", e) }, get description() { return this._firstProp("description") }, set description(e) { this._setProp("description", e) }, get organizer() { return this._firstProp("organizer") }, set organizer(e) { this._setProp("organizer", e) }, get sequence() { return this._firstProp("sequence") }, set sequence(e) { this._setProp("sequence", e) }, get recurrenceId() { return this._firstProp("recurrence-id") }, set recurrenceId(e) { this._setProp("recurrence-id", e) }, _setTime: function (e, t) { var n = this.component.getFirstProperty(e); if (!n) { n = new ICAL.Property(e); this.component.addProperty(n) } if (t.zone === ICAL.Timezone.localTimezone || t.zone === ICAL.Timezone.utcTimezone) { n.removeParameter("tzid") } else { n.setParameter("tzid", t.zone.tzid) } n.setValue(t) }, _setProp: function (e, t) { this.component.updatePropertyWithValue(e, t) }, _firstProp: function (e) { return this.component.getFirstPropertyValue(e) }, toString: function () { return this.component.toString() } }; return t }(); ICAL.ComponentParser = function () { function e(e) { if (typeof e === "undefined") { e = {} } var t; for (t in e) { if (e.hasOwnProperty(t)) { this[t] = e[t] } } } e.prototype = { parseEvent: true, parseTimezone: true, oncomplete: function () { }, onerror: function (e) { }, ontimezone: function (e) { }, onevent: function (e) { }, process: function (e) { if (typeof e === "string") { e = ICAL.parse(e)[1] } if (!(e instanceof ICAL.Component)) { e = new ICAL.Component(e) } var t = e.getAllSubcomponents(); var n = 0; var r = t.length; var i; for (; n < r; n++) { i = t[n]; switch (i.name) { case "vtimezone": if (this.parseTimezone) { var s = i.getFirstPropertyValue("tzid"); if (s) { this.ontimezone(new ICAL.Timezone({ tzid: s, component: i })) } } break; case "vevent": if (this.parseEvent) { this.onevent(new ICAL.Event(i)) } break; default: continue } } this.oncomplete() } }; return e }()